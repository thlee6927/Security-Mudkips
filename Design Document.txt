Overall Design
	The format of the .atm and .bank files that init creates is as follows
		48 randomly generated bytes to represent a 32 byte key and 16 byte IV for a theoretical AES cbc form of encryption/decryption
	The format of the .card files that the bank generates for each new account is as follows
		Bytes 	Contains
		4 		Integer Length of the account name
		1-250	The actual account name, length specificed by first 4 bytes
		32		The 32 byte SHA256 hash of the account's PIN number
	There are 3 different types of Messages that Bank and the ATM send to each other, and the format is
		Opcode		Message Data			HASH
		1 byte 		n bytes 				32 bytes
		Where the HASH is the SHA256 Hash of the message data using the accounts PIN as a salt
		Return messages from the Bank to the ATM consist of the Opcode and a single byte to signify whether the operation was correctly performed (unless otherwise stated)

		and the actual messages are
			Opcode 		Operation						Message format 									Notes
			01			If <username> exists			[Length of the name(4bytes), name (n bytes)]	This does not have a corresponding Hash
			02			Withdraw						[Length of name(4), name(n), amount(4)]			
			03			Balance							[Length of the name(4), name(n)]				Return includes 4 bytes for the Integer Balance

		Messages also fail when the hash (with salt specificed above) of the Message Data that the ATM sent is not the same as the Hash the ATM provided

Threats Considered
	-Buffer Overflow
		Countered by meticulously checking the actual sizes of the buffer to whatever it was being used for
	-Authenticating ATM user
		By using the user's PIN number as a Salt for the SHA256 hash of the messages being sent
	-Restarting the ATM
		The bank does not store the current user of an ATM, the ATM stores it in its own internal memory
	-Remotely depositing money through ATM
		Withdraws from the ATM only takes inputs that are positive
	-UDP being generally unreliable
		Did not have enough time to implement
			With UDP having the chance of packets being out of order or duplicated, messages sent that have side effects could be duplicated
			Or even an attacker trying to duplicate a message, one way to counteract this is have a sort of "sequence number" that is randomly generated that would help prevent sorts of things like this
	-Man in the middle
		Did not have enough time to FULLY implement
			While messages altered by a man in the middle would not be accepted, as the hash would not match up, however there is no retransmission of any messages that may have been altered by an outside force